# Task: INT-003

## Metadata
| Field | Value |
|-------|-------|
| Lane | INTEGRATION |
| Type | ADD_PURE_FN |
| Wave | - |
| Status | PENDING |
| Created | 2026-01-15 |
| Assigned | - |

## Context Pack

### Files
- /home/ubuntu/projects/zerg-swarm/SWARM/SCRIPTS/swarm.py

### Target Code
Lines 18-21 in swarm.py - save_state function:
```python
def save_state(state):
    state["last_updated"] = datetime.now().isoformat()
    with open(STATE_FILE, 'w') as f:
        json.dump(state, f, indent=2)
```

### Current Issue
The save_state() function directly writes to STATE.json without any file locking mechanism. Multiple agents (Zerglings) can read/write STATE.json concurrently, causing:
- **CRITICAL Race Condition**: Agent A reads STATE, Agent B reads STATE, Agent A writes, Agent B writes (loses A's changes)
- **Data Corruption**: Partial JSON writes or interleaved file access
- **No Reservation Integration**: Doesn't check SWARM/LOCKS/ directory or file reservation protocol

### Expected Behavior After Fix
1. Before writing: Check for lock file at SWARM/LOCKS/STATE.json.lock
2. If lock exists and not expired (>30s): Wait with exponential backoff or fail gracefully
3. If lock doesn't exist or expired: Create lock file with agent ID and timestamp
4. Write STATE.json atomically
5. Remove lock file after successful write
6. Handle timeout gracefully (log, skip write, or escalate)

## Objective
Add file locking protocol integration to prevent race conditions on STATE.json by implementing lock file creation, pre-write validation, and timeout handling in swarm.py.

## Deliverables
- [ ] Create `acquire_lock(timeout_sec=5)` function that creates SWARM/LOCKS/STATE.json.lock with agent metadata
- [ ] Create `release_lock()` function that safely removes lock file
- [ ] Create `check_lock()` function that validates lock freshness (timeout after 30s)
- [ ] Modify save_state() to acquire lock before write, release after
- [ ] Add exponential backoff retry logic (3 attempts, 100ms-500ms delay)
- [ ] Add logging for lock acquire/release/timeout events
- [ ] Add timeout error handling with graceful degradation

## Acceptance Criteria (INTEGRATION Gate)
- [ ] Unit test: acquire_lock() creates lock file with metadata
- [ ] Unit test: release_lock() removes lock file cleanly
- [ ] Unit test: check_lock() correctly identifies stale locks (30s+)
- [ ] Unit test: save_state() acquires lock before write, releases after
- [ ] Integration test: Two concurrent save_state() calls serialize correctly (no race condition)
- [ ] Linting: All code passes flake8/black standards

## Check Command
```bash
# Verify lock file created during state save
python3 /home/ubuntu/projects/zerg-swarm/SWARM/SCRIPTS/swarm.py wave && \
ls -la /home/ubuntu/projects/zerg-swarm/SWARM/LOCKS/ && \
cat /home/ubuntu/projects/zerg-swarm/SWARM/STATE.json | jq '.wave'
```

## Constraints
- Max 150 lines of new code
- Max 1 file (swarm.py)
- No new external dependencies (use stdlib only)
- Must maintain backward compatibility with existing load_state()/save_state() signatures

## Notes
- Related to CLAUDE.md Agent Mail Protocol: file reservations must be respected in swarm state management
- Lock timeout of 30s prevents deadlocks but allows reasonable write operations
- Exponential backoff (100ms â†’ 500ms) prevents thundering herd if multiple agents contend
- Must use pathlib.Path for cross-platform compatibility (already used in swarm.py)

## Dependencies
- INT-001 (SWARM/LOCKS/ directory must exist before this runs)
